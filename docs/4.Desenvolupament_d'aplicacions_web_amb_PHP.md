# Desenvolupament d'aplicacions web amb PHP (avançat)

Taula de continguts

* [Sessions i seguretat](#sessions-i-seguretat)
* [Exempcions i errors](#exempcions-i-errors)
* [Bases de dades](#acces-a-bases-de-dades)
* [Classes i objectes](#classes-i-objectes)
* [Correu electrònic](#enviament-de-correu-electronic)
* [Proves](#proves)
* [Composer](#composer)


## Sessions i seguretat

Com Http és un protocol sense estat, les diferents peticions d'un client a un servidor són independents, no estan relacionades entre si. Per associar-les s'utilitzen les sessions. 

El terme sessió fa referència al conjunt d'informació relativa a un usuari concret. Aquesta informació pot ser tan simple com el nom del propi usuari, o més complexa, com els articles que ha dipositat en la cistella de compra d'una tenda online.

Cada usuari diferent d'un lloc web té la seua pròpia informació de sessió.Per a distingir una sessió d'una altra s'usen els identificadors de sessió (SID). Un SID és un atribut que s'assigna a cadascun dels visitants d'un lloc web i ho identifica. Si el servidor web utilitza el SID d'un usuari, per a relacionar-ho amb la informació que posseeix sobre ell, que es manté en la sessió de l'usuari.

El procés de maneig de sessions en PHP està automatitzat. 

#### Accedir a les dades de la sessió

* Una vegada oberta la sessió, usem la variable superglobal  **$_SESSION** per a afegir informació a la sessió de l'usuari, o per a accedir a la informació emmagatzemada en la sessió
* Per exemple, per a explicar el nombre de vegades que l'usuari visita la pàgina, podem fer: 

 ```php
// Iniciem la sessió o recuperem l'anterior sessió existent 
session_start(); 
// Comprovem si la variable ja existeix 
if (isset($_SESSION['visites']))
	$_SESSION['visites']++; 
else
	$_SESSION['visites'] = 0;
 ```

#### Eliminar una variable de la sessió
* Per a eliminar una variable de la sessió usarem la funció unset()

 ```php
	unset($_SESSION['visites']);
 ```
 
* Per a tancar la sessió de forma manual utilitzarem la funció **session_destroy()**
* Abans hem d'eliminar les variables de la sessió de la següent forma:
	*  $_SESSION = [];

#### Autenticació amb sessions
* Probablement, l'ús més estès del control de sessions siga el seguiment d'usuaris autenticats a través d'un mecanisme d'inici de sessió. Per a açò necessitarem un formulari de login.

login.php

```php
<?php
/*formulario de login habitual
si va bien abre sesión, guarda el nombre de usuario y redirige a principal.php 
si va mal, mensaje de error */
function comprobar_usuario($nombre, $clave){
	if($nombre === "usuario" and $clave === "1234"){
		$usu['nombre'] = "usuario";
		$usu['rol'] = 0;
		return $usu;
	}elseif($nombre === "admin" and $clave === "1234"){
		 $usu['nombre'] = "admin";
		 $usu['rol'] = 1;
		 return $usu;
	}else return false;
}
if ($_SERVER["REQUEST_METHOD"] == "POST"){  
	$usu = comprobar_usuario($_POST['usuario'], $_POST['clave']);
	if($usu==false){
		$err = true;
		$usuario = $_POST['usuario'];
	}else{	
		session_start();
		$_SESSION['usuario'] = $_POST['usuario'];
		header("Location: principal.php");
	}	
}
?>
<!DOCTYPE html>
<html>
	<head>
		<title>Formulario de login</title>		
		<meta charset = "UTF-8">
	</head>
	<body>	
		<?php if(isset($_GET["redirigido"])){
			echo "<p>Haga login para continuar</p>";
		}?>
		<?php if(isset($err) and $err == true){
			echo "<p>revise usuario y contraseña</p>";
		}?>
		<form action = "<?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?>" method = "POST">
			Usuario: 
			<input value = "<?php if(isset($usuario))echo $usuario;?>"
			id = "usuario" name = "usuario" type = "text">							
			Clave :			
			<input id = "clave" name = "clave" type = "password">
			<input type = "submit">
		</form>
	</body>
</html>

```
 
principal.php
 
 ```php
 <?php 
	session_start();
	if(!isset($_SESSION['usuario'])){	
		header("Location: sesiones1_login.php?redirigido=true");
	}	
?>
<!DOCTYPE html>
<html>
	<head>
		<title>Página principal</title>
		<!--<link rel = "stylesheet" href = "./css/alta_usuarios.css">-->
		<meta charset = "UTF-8">
	</head>
	<body>		
		<?php echo "Bienvenido ".$_SESSION['usuario'];?>
		<br><a href = "logout.php"> Salir <a>
	</body>
</html>
 ```
 
logout.php
 
 ```php
<?php
	session_start();    // unirse a la sesión
						//comprobar si existe la variable usuario????
	$_SESSION = array();
	session_destroy();	// eliminar la sesion
	header("Location: login.php");
 ```
 
La informació d'autenticació (nom i contrasenya dels usuaris) s'envia en text pla des del navegador fins al servidor web. Açò és altament insegur i mai ha d'usar-se sense un protocol com a HTTPS que permeta xifrar les comunicacions amb el servidor web.

#### Objectes i arrays

 Si volem guardar un objecte o un array en una variable de sessió primer l'hem de transformar amb serialize() i despres, quan el recuperem, haurem d'utilitzar unserialize()

* És el moment de fer més exercisis: [Exercisi 3.2 Sessions i seguretat](3.2.Activitat.md)






## Enviament de correu electronic

Encara que la funció **mail()** permet l'enviament de correus electrònics, és habitual utilitzar alguna llibreria que s'ocupe dels detalls del format.

```
 composer require phpmailer/phpmailer
```
o modificant el composer.json per afegir la linea "phpmailer/phpmailer": "~6.1" dins del require

```
 "require": {
        "filp/whoops": "^2.4",
        "phpmailer/phpmailer": "~6.1"
    },
```
i executant els composer update

En principi es possible enviar un correu utilitzant la configuració de sendmail (en Linux) o un servidor SMTP local, en la pràctica els filtres antispam fan que no arriben els correus enviats des de servidors no registrats correctament. A més des de les aules tampoc es pot fer.

Si no es disposa d'un servidor de correu en Internet, l'opció més comoda per tal d'enviar un correu és utilitzar un compte de Gmail. En Gmail cal activar l'opció "Permetre aplicacions meyns segures" en la secció d'ajustos de compte. Açò va a canviar en breu i no es podrà utilitzar sinó que haurem d'identificar-nos amb Oauth.
Teniu informació disponible en el [github](https://github.com/PHPMailer/PHPMailer) de php mailer.


El següent programa permet enviar un correu mitjançant Google:

```php
<?php 	
 	use PHPMailer\PHPMailer\PHPMailer;
	use PHPMailer\PHPMailer\SMTP;
	use PHPMailer\PHPMailer\Exception;
 	require "vendor/autoload.php";
 	
	try {
	    //Server settings
	    $mail->SMTPDebug = SMTP::DEBUG_SERVER;                      // Enable verbose debug output
	    $mail->isSMTP();                                            // Send using SMTP
	    $mail->Host       = 'smtp.gmail.com';                    // Set the SMTP server to send through
	    $mail->SMTPAuth   = true;                                   // Enable SMTP authentication
	    $mail->Username   = '2daw2021batoi@gmail.com';                     // SMTP username
	    $mail->Password   = 'batoi_1234';                               // SMTP password
	    $mail->SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS;         // Enable TLS encryption; `PHPMailer::ENCRYPTION_SMTPS` encouraged
	    $mail->Port       = 587;                                    // TCP port to connect to, use 465 for `PHPMailer::ENCRYPTION_SMTPS` above

	    //Recipients
	    $mail->setFrom('from@example.com', 'Mailer');
	    $mail->addAddress('joe@example.net', 'Joe User');     // Add a recipient
	    $mail->addAddress('ellen@example.com');               // Name is optional
	    $mail->addReplyTo('info@example.com', 'Information');
	    $mail->addCC('cc@example.com');
	    $mail->addBCC('bcc@example.com');

	    // Attachments
	    $mail->addAttachment('/var/tmp/file.tar.gz');         // Add attachments
	    $mail->addAttachment('/tmp/image.jpg', 'new.jpg');    // Optional name

	    // Content
	    $mail->isHTML(true);                                  // Set email format to HTML
	    $mail->Subject = 'Here is the subject';
	    $mail->Body    = 'This is the HTML message body <b>in bold!</b>';
	    $mail->AltBody = 'This is the body in plain text for non-HTML mail clients';

	    $mail->send();
	    echo 'Message has been sent';
	} catch (Exception $e) {
	    echo "Message could not be sent. Mailer Error: {$mail->ErrorInfo}";
	}
```
On us he possat unes credencials que podeu gastar per al curs i no tenir que obrir un compte cadascú.


## Proves

Per a executa proves la ferramenta més utilitzada en php és phpunit.

```
composer require --dev phpunit/phpunit
```

L'element base del phpunit es el **cas de prova**, una classe que ha d'heretar de **TestCase** de la llibreria. Dins d'un cas de prova hi ha varias proves.
Per a provar una classe de nom **Usuari** es crearà una classe de nom **UsuariTest**. Esta classe contindrà una sèrie de mètodes amb les proves que es volen realitzar. Estos mètodes han de ser publics, encara que les classe podrà contindre altres mètodes auxiliars per tal de realitzar les proves.
Per a indicar que el mètode és una prova hi ha dues opcions:

* Que el nombre començe per test

```php
public function testCanCreateUsuari()
```

* Utilitzar un bloc de comentaris específics amb la notació test  

```php
/**
/* #test
*/
public function testCanCreateUsuari()
```

Dins d'estos mètodes, la majoria de les comprovacions es realitzen utilitzant **asserts**, mètodes definits en la classe **TestCase**, que comprova si es complixen o no algunes condicions. Si alguna de les assercions no s'acomplixen es considera que la prova ha fallat.

Per exemple podem provar la classe següent:

```php
<?php
   class Matematicas{
	/* funcion factorial */
		public static function factorialEx($num){
			if ($num < 0) {
				throw new InvalidArgumentException("N�mero negativo");
			}	
			$resul = 1;
			for($i=2; $i <= $num; $i++){
				$resul = $resul * $i;
			}
			return $resul;
		}
   }
```
  
amb la següent classe:

```php
<?php
	require "vendor/autoload.php";
	require "Matematicas.php";
	use PHPUnit\Framework\TestCase;
	class MatematicasTest extends TestCase{    		
		public  function testCero(){
			$this->assertEquals(1, Matematicas::factorialEx(0));						
		}		
		/**
		* @test
		* @expectedException InvalidArgumentException
		*/
		public static function Excepcion(){
			//equivalente a la anotación  @expectedException
			//$this->expectException(InvalidArgumentException::class);
			return Matematicas::factorialEx(-1);			
			
		}
	}   
```

on el primer mètode comprova que calcula be el factorial de 0, i el segon mètode comprova que si el paràmetre és negatiu es llança una exempció.

Per a executar la prova cal executar phpunit des de la línea de comanaments

```
 /vendor/bin/phpunit MatematicasTest.php
```

Més exemples: Podem provar les funcions que ja hem fet i que tenim al myHelpers:

```php
<?php
/**
 * Created by PhpStorm.
 * User: igomis
 * Date: 2019-10-17
 * Time: 22:59
 */

require dirname(__FILE__) . "/../vendor/autoload.php";
$whoops = new \Whoops\Run;
$whoops->pushHandler(new \Whoops\Handler\PrettyPageHandler);
$whoops->register();

use PHPUnit\Framework\TestCase;

class FunctionsTest extends TestCase
{
    public function test_calculadora()
    {
        $this->assertEquals(13,suma(6,7));
        $this->assertEquals(-1,resta(6,7));
        $this->assertEquals(42,multiplicacion(6,7));
        $this->assertEquals('4 + 6 = 10',calculadora('+',4,6));
    }
}
```

o les classes Form i SIInput per a generar formulari

```php
<?php
/**
 * Created by PhpStorm.
 * User: igomis
 * Date: 2019-10-17
 * Time: 22:59
 */

require dirname(__FILE__) . "/../vendor/autoload.php";
$whoops = new \Whoops\Run;
$whoops->pushHandler(new \Whoops\Handler\PrettyPageHandler);
$whoops->register();

use Ejercicios\Form;
use Ejercicios\SIInput;
use PHPUnit\Framework\TestCase;


class FormTest extends TestCase
{

    public function test__construct()
    {
        $form = new Form([new SIInput('Usuari','usuario'),new SIInput('Password','password','password')]);
        $this->assertIsArray($form->getComponents());
        $this->assertCount(2,$form->getComponents());
    }

    public function testRender()
    {
        $form = new Form([new SIInput('Usuari','usuario'),new SIInput('Password','password','password')]);
        $this->assertStringContainsString('password',$form->render());
    }
}
```

```php
<?php
/**
 * Created by PhpStorm.
 * User: igomis
 * Date: 2019-10-17
 * Time: 22:59
 */

require dirname(__FILE__) . "/../vendor/autoload.php";
$whoops = new \Whoops\Run;
$whoops->pushHandler(new \Whoops\Handler\PrettyPageHandler);
$whoops->register();

use Ejercicios\SIInput;
use PHPUnit\Framework\TestCase;



class SIInputTest extends TestCase
{
    public function test_works_textArea()
    {
        $input = new SIInput('Usuari','usuario','textarea');
        $this->assertStringContainsString('textarea',$input->render());
    }
    public function test_works_textInput()
    {
        $input = new SIInput('Usuari','usuario');
        $this->assertStringContainsString('text',$input->render());
    }

    public function test_works_textPass()
    {
        $input = new SIInput('Usuari','usuario','password');
        $this->assertStringContainsString('password',$input->render());
    }
}

```
Com veiem cada test conté una instaciació de l'element que es vol provar i una comprobaciò del resultat.

Per a més informacio [phpunit](https://phpunit.readthedocs.io/es/latest/writing-tests-for-phpunit.html)



## Composer

Composer ens resol dos problemes:

* Gestionar les dependències amb llibreries de tercers (N'hi ha prou que declarem les dependències i Composer s'encarregarà de descarregar i instal·lar tot el que siga necessari)
* Autoloading del nostre codi (Ja no haurem de fer més requires, Composer ho farà per nosaltres)

#### Gestió de les dependències

* La instal·lació de les llibreries sempre és local per a cada projecte
* S'instal·len en un directori del projecte
* Per defecte aqueix directori és vendor/
* Passos:
	* Declarar les llibreries de les quals depèn el projecte
	* Composer descàrrega i instal·la automàticament les versions correctes de cadascuna d'aqueixes llibreries i les seues dependències

#### Instal·lació 
* Es pot instal·lar localment per a cada projecte o globalment
* Anem a instal·lar-ho globalment:

```
$curl -sS https://getcomposer.org/installer | php  
sudo mv composer.phar /usr/local/bin/composer
```

* Hem descarregat composer i ho hem mogut a un directori que està dins del PATH. A partir d'ara, podem executar Composer simplement escrivint composer

#### Preparar l'arxiu composer.json
* Necessari per a usar composer en un projecte
* Consisteix en una sèrie d'estructures d'informació niades
* Exemple:

```
 {"require": { "monolog/monolog": "1.2." } }
```

* require mapea noms de paquets (en l'exemple, monolog/monolog) amb versions de paquets (en aquest cas, 1.2.)

#### Exemple d'ús
* Estem desenvolupant un projecte i necessitem una llibreria per a guardar missatges de log
* Decidim utilitzar la llibreria monolog
* Per a incloure aquesta llibreria:
	* Anem a crear un arxiu composer.json

```
{ "require": {"monolog/monolog": "1.0." } } 
```
	
Estem indicant que el projecte depèn d'un paquet anomenat monolog/monolog i que li serveix qualsevol versió la numeració de la qual comence per 1.0

#### Noms de paquets
* Està format per dues parts:
	* La primera indica qui és la seua "vendor" o creador 
	* La segona indica el nom del projecte
* Sovint les dues parts són idèntiques
* El nom del creador és important per a evitar col·lisions entre projectes amb el mateix nom
 
#### Versions de paquets
* En l'exemple anterior, la versió requerida de la llibreria és 1.0.
* Es pot utilitzar qualsevol versió de la branca 1.0 (com per exemple 1.0.0, 1.0.2 o 1.0.20)
* Aquesta versió és equivalent a =1.0 > <1.1
* Les versions requerides es poden especificar de moltes maneres:
	* Versió exacta: com per exemple 1.0.2 
	* Rang de versions: S'usen operadors de comparació: >, >=, <, <=, !=.
( Exemples: >=1.0 o >=1.0,<2.0)
	* Comodins: La versió 1.0. per exemple és equivalent a =1.0, ><1.1 
	* La següent versió significativa: que s'indica mitjançant l'operador ~ i s'interpreta de la següent manera: ~1.2 és equivalent a =1.2, ><2.0, mentre que ~1.2.3 és equivalent a =1.2.3, ><1.3 (útil per a aquells projectes que segueixen el versionat semàntic)

#### Versionat semàntic (Semver)
* Els nombres de versió i la forma en què canvien informen sobre el que va ser modificat d'una versió a una altra
* Veure l'especificació en el següent document:
	* http://semver.org/lang/es/

#### Instal·lant les dependències
* Executem el següent comando:

```
 composer install
```

* Es generarà el directori vendor/ amb les llibreries de les quals depèn el projecte
* MOLT IMPORTANT: Hem d'afegir el directori vendor/ a l'arxiu .gitignore
* El comando també crea un arxiu composer.lock


#### L'arxiu composer.lock

* Guarda la versió exacta que s'ha instal·lat de cada llibreria
* El projecte es fixa a unes determinades versions
* Tant el composer.lock com el composer.json han d'estar en el repositori
* El comando install comprova primer si existeix l'arxiu composer.lock, i si existeix, descàrrega exactament les versions que s'indiquen en aqueix arxiu
* Si treballem en equip, tot l'equip tindrà les mateixes versions
 
#### Actualitzar versions
* Si tenim l'arxiu composer.lock sempre s'instal·laran les mateixes versions de les llibreries
* Per a actualitzar a noves versions, usem el comando update
* Fa que **composer** cerque les versions més recents de les llibreries
* Sempre que seguisquen complint les restriccions de les versions indicades en l'arxiu composer.json
* També actualitza l'arxiu composer.lock
* Si solament volem instal·lar o actualitzar una dependència, podem indicar el seu nom després del comando:

```
 composer update monolog/monolog
```

#### Afegint dependències
* El comando require afig noves dependències en l'arxiu composer.json
	* composer require
* Ens preguntarà què llibreries volem afegir
* Després d'afegir aquestes noves dependències, s'instal·len o actualitzen les dependències que siguen necessàries
* Podem passar les noves dependències com a argument del comando

```
 composer require monolog/monolog:1.
```

#### Packagist
* Repositori central de Composer (lloc del que s'obtenen els paquets)
* Lloc web: http://packagist.org
 
#### Càrrega automàtica de classes
* Normalment les llibreries proporcionen informació sobre la càrrega automàtica de les seues classes
* Composer genera un arxiu vendor/autoload.php
* Incloent aquest arxiu en el projecte, podem utilitzar qualsevol classe instal·lada a través de Composer sense haver d'incloure-la explícitament:

```
 require 'vendor/autoload.php';
```

#### Ús de la llibreria
* Per a usar la llibreria Monolog podem usar les seues classes i Composer s'encarregarà de carregar-les:

```
$log = new Monolog\Logger('name'); 

$log->pushHandler(
new Monolog\Handler\StreamHandler('app.log', Monolog\Logger::WARNING) );

$log->addWarning('Foo');
```

#### Espais de noms
* Són una manera d'encapsular elements
* Podemos fer un simil entre els namespaces i els directoris:
	* Els directoris serveixen per a agrupar fitxers relacionats 
	* El fitxer foo.txt pot existir en els directoris /home/greg i /home/un altre, però no poden coexistir dues còpies de foo.txt en el mateix directori
	* Per a accedir al fitxer foo.txt fóra del directori /home/greg,
s'ha d'anteposar el nom del directori al nom del fitxer, emprant el separador de directoris per a així obtenir /home/greg/foo.txt
* Aquest mateix principi s'estén als espais de noms en el món de la programació

#### Introducció als namespaces
* Els namespaces són una característica de PHP que s'introdueix en la versió 5.3
* L'ús de namespaces és molt convenient per dos motius:
 	* El conflicte de noms entre el codi que es crea i les
classes/funciones/constants internes de PHP o les classes/funciones/constants de tercers 
	* La capacitat de sobrenomenar (o abreujar) Noms_Extra_Llargs millorant la llegibilitat del codi font
* Només usarem namespaces per a noms de classes
 
#### Definir espais de noms
* Només les classes (incloent abstractes i traits), interfícies, funcions i constants es veuen afectats per espais de noms
* Es declaren utilitzant la paraula reservada namespace
* S'ha de declarar a l'inici del fitxer, abans que qualsevol altre codi
* Només hi ha una excepció: la paraula reservada declare

```
namespace MiProyecto;

const CONNECTAR_OK = 1; 

class Connexió { / ... / } 

function connectar() { / ... / }
```
 
#### Ubicació de la declaració
* Tot el que no siga codi PHP no pot precedir a la declaració de l'espai de noms

```
 <html> <?php namespace MiProyecto;
 
  // error fatal - el espacio de nombres debe ser la primera sentencia del script ?>
```

#### Declarar subespacios de noms
* Un nom d'un espai de noms es pot definir amb subnivells

```
namespace MiProyecto\Sub\Nivell;

const CONNECTAR_OK = 1; 

class Connexió { / ... / } 

function connectar() { / ... / }
```

#### Ús de namespaces en els nostres projectes
* Cada aplicació que creiem tindrà un espai de noms diferent
* Podrem separar els subnoms del namespace amb el caràcter \
* Per exemple:

```
namespace CursoPhp7\Core; Class Request { ... }
```

* La classe Request estarà dins de l'espai de noms CursoPhp7\Core

#### Usar elements que estan dins de namespaces
* Per a poder usar la classe Request de l'exemple anterior haurem d'indicar el 

```
nom complet CursoPhp7\Core\Request
```

* Per a abreujar els usos podem utilitzar la instrucció use que permet indicar els espais de noms que anem a utilitzar:

```
use CursoPhp7\Core\Request;
```

* Ara ja podrem usar la classe Request sense indicar la ruta completa
* També podem definir un àlies per a una classe de la següent forma:

```
use CursoPhp7\Core\Request as Req;
```

* Ara podrem usar la classe Request com Req
* És una molt bona pràctica fer coincidir els namespaces amb els directoris on es troben els arxius
* Açò ens permetrà utilitzar el autoloader de Composer que veurem més endavant
* En el nostre projecte tots els arxius pengen del directori \
* Més endavant, veurem que podem associar el nom del directori de nostre projecte amb un espai de noms, per exemple, CursoPhp7.
* Per tant, els namespaces començaran per CursoPhp7\
* Per exemple:
	* CursoPhp7\App\Controllers o CursoPhp7\Core o CursoPhp7\Database o ...

#### Afegir els uses
* En tots els llocs on utilitzem un namespace, haurem d'afegir l'use de l'espai de noms corresponent
* A més, quan utilitzem una classe d'alguna llibreria o del propi PHP, com per exemple PDO, haurem d'afegir-li una \ davant per a indicar que la classe està en l'espai de noms arrel

```
return $statement->fetchAll(
\PDO::FETCH_CLASS, 'Agenda\\Entities\\'.$classEntity);
```

#### Autoloading amb Composer
* Cada vegada que afegim una nova classe a la nostra aplicació hem d'inserir el require corresponent en el nostre bootstrap.php
* Per a evitar açò podem utilitzar l'eina composer amb la seua funcionalitat de autoloading
 
##### Càrrega automàtica de les nostres classes

* La càrrega automàtica de classes en composer es controla mitjançant la propietat autoload de l'arxiu composer.json
* Es permeten quatre valors:
	* El carregador de classes que segueix l'estàndard PSR-0 
	* El carregador de classes que segueix l'estàndard PSR-4 (substitueix a l'anterior)
	* El mapa de classes (classmap) 
	* Els arxius individuals (files)
* El mètode recomanat és el carregador PSR-4 perquè és el més flexible (no fa falta per exemple regenerar el carregador de classes quan s'afig una nova classe al projecte)

#### Ús de PSR-4
* Podemos consultar l'especificació en la següent url:
	* http://www.php-fig.org/psr/psr-4/
* Es basa que els noms dels namespaces han de coincidir amb els directoris on se situen els arxius
* Per a activar-ho afegirem la clau autoload indicant l'opció psr-4 i amb quin directori es mapea el namespace principal

##### Exemple

```
{
"autoload": {"psr-4": {"Acme\\": "src/"} } }
```

* Composer crearà un carregador automàtic de classes per al namespace Acme que seguirà les normes de l'estàndard PSR-4 de PHP
* El directori src/ estarà en l'arrel del projecte, al mateix nivell que el directori vendor/
* Contindrà el codi del projecte
* Així, l'arxiu src/Acme/Foo.php hauria de contenir la classe Acme\Foo
* Després d'afegir l'opció autoload, cal executar el comando **composer dump-autoload** perquè es regenere l'arxiu vendor/autoload.php

#### Incloure el autoloader
* Perquè tot funcione correctament caldrà incloure el fitxer autoload.php en el controlador frontal (index.php) abans d'incloure el bootstrap.php
* Ara podrem eliminar tots els requires de classes que tinguem en el bootstrap.php
* El autoload s'encarregarà cercar els fitxers i utilitzar-los
	
